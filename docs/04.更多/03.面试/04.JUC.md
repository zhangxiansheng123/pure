---
title: JUC
date: 2021-12-19 22:47:19
permalink: /pages/ca0cd0/
categories: 
  - 更多
  - 面试
tags: 
  - null
author: 
  name: MoXi
  link: https://github.com/zhangxiansheng123
---
## JUC

- [ ] Threadlocal如何导致内存泄露，如何销毁

- [ ] 并发包下面都有那些类，对应的业务场景是什么

- [x] 一个controller并发访问安全吗

  * controller默认是单例的，一般是安全的，但是在controller中使用了实例变量，就可能出现线程不安全的情况。
  * 解决方法：不要在 Controller 中定义成员变量，万一必须要定义一个非静态成员变量时候，则通过注解 @Scope(“prototype”)，将其设置为多例模式，在 Controller 中使用 ThreadLocal 变量；

- [x] volatile的作用

  * 内存可见性：当对非volatile变量进行读写的时候，每个线程先从主内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。**每次`读取前`必须先从主内存刷新最新的值，每次写入后必须立即同步回主内存中。**
  * 有序性：防止指令重排，通过内存屏障
  * 无法保证原子性：
  * 简化的同步机制，简化版的synchronized，不会阻塞线程，写的操作稍微慢一些，因为写会有内存屏障，读的性能完全没有影响。

- [x] 什么情况线程不安全

  * 多线程在同一时刻对一个共享资源做写操作（读操作不会涉及线程不安全），和我们的预期结果不一样，就出现了线程不安全问题。

- [x] 线程是怎样实现的

- [x] 多线程有用到过吗，怎么实现的

- [ ] 讲一讲多线程，三个线程依次打印几种实现方式

- [ ] 手写两个线程排序执行

- [x] 线程有哪些状态  阻塞和等待有什么区别

- [ ] 线程安全的集合有哪些

- [ ] hashmap原理，它是线程安全的吗，有什么是线程安全的

- [ ] ConcurrentHashmap底层

- [ ] 并发包下都用过那些类

- [ ] JUC的包用过没有，里面读写安全的map是什么

- [x] 实现线程有哪几种方式？都是怎么实现的？（高频）

- [x] 什么是线程不安全的？怎么做到线程安全的

- [x] 获取多线程的方法有几种？(四种)

  * 传统的是继承thread类和实现runnable接口
  * java5以后又有实现callable接口+ FutureTask和java的线程池获得

- [x] 说一下锁？

  * 在并发编程中，经常会遇到多个线程访问同一个共享资源，这个时候就必须考虑维护数据的一致性，在java中的synchronized（同步锁）关键字和juc（java.util.concurrent包）中的Lock锁。

    synchronized

- [x] 什么是乐观锁？什么又是悲观锁？

  * **悲观锁就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据的时候就会阻塞，直到拿到锁。**

  * Java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁算法去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。

  * 乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

  * **Java中的乐观锁基本都是通过CAS操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。**

    注意：**CAS（compare and swap）是解决多线程并发安全问题的一种乐观锁算法。**因为它在对共享变量更新之前，会先比较当前值是否与更新前的值一致，如果一致则更新，如果不一致则循环执行（称为自旋锁），直到当前值与更新前的值一致为止，才执行更新。 自旋锁（SpinLock）是指：尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，可以自旋一会就获得锁，减少线程上下文切换的消耗，缺点是循环会消耗CPU，实际开发一般不会一直获取不到锁。

- [x] 乐观锁与悲观锁的区别，高并发的情况下使用哪个

  * 区别见上
  * 高并发悲观锁比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。
  * 乐观锁比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大（ABA对依赖过程值的情景的运算结果影响很大），为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。
  * **乐观锁是基于cas实现的,高并发场景下，需要无限自旋，浪费资源，存在性能问题，所以使用悲观锁。**

- [x] Java中锁的实现方式，请解释一下悲观锁和乐观锁

- [ ] 用过哪些锁？他们是乐观锁还是悲观锁？使用层面lock是悲观锁还是乐观锁？

- [ ] 自旋锁有了解过吗？

- [ ] 锁的几种类型，它们有什么区别，具体怎么实现的

- [x] synchronized的底层说一下？

  * https://www.cnblogs.com/aqiu-jiang/p/11732760.html

- [x] synchronized怎么优化？

- [x] 如何避免死锁的产生

- [x] java公平锁原理

- [x] synchronized和static synchronized的区别？

- [x] synchronized关键字：悲观的独占的排他的互斥的非公平的可重入的重量级锁

  * 静态同步方法锁类
  * 普通同步方法锁对象
  * 同步代码块锁的是小括号中的资源
  * 而静态同步方法（Class对象锁）与非静态同步方法（实例对象锁）之间是不会有竞态条件的。

- [ ] juc中ReentrantLock：悲观的独占的排他的互斥的可公平可非公平的可重入的重量级锁

  * ReentrantReadWriteLock：可重入的读写锁
        写写不可并发的
    		读写不可并发的
    		读读可以并发的

- [x] ReentrantLock和synchronized区别（*2）

  * 都是悲观的独占的排他的互斥的重量级锁，synchronized自动加锁和解锁，使用起来更加简单，ReentrantLock手动加锁和解锁，使用起来相对麻烦一点，更加灵活。
  * 它们都是可重入的，synchronized不需要考虑加锁次数；ReentrantLock加解锁次数必须一致
  * ReentrantLock是可非公平的也可公平的；synchronized是公平的
  * ReentrantLock是具体的实现类，synchronized是一个关键字，无法查看源代码
  * synchronized不能响应中断；ReentrantLock可以响应中断
  * 线程通信方式不同：synchronized（wait notify、notifyAll） ReentrantLock（condition对象：await singal、singalAll）

- [x] 线程池用在项目哪些地方

- [x] 线程池用过那些类型

- [x] 线程池的几种类型，线程池工作原理

  * 线程池的类型和作用：https://www.cnblogs.com/vince66/p/9325638.html
  * 线程池的工作原理：见下。。

- [x] 线程池的参数有哪些 核心线程数和最大线程数一般多少

- [ ] 怎么提高多线程的执行效率

- [x] 线程池怎么管理

- [x] 使用线程池的好处

- [x] 线程池中的线程怎么添加一个线程 删除一个线程

- [x] Java中有提供几种线程池的创建方式

- [x] 线程池的原理，以及线程池的好处，拒绝策略等？

- [x] 线程池是怎么创建的，参数了解吗，实现原理知道吗，知道为什么要使用阻塞队列而不使用队列吗

  * 7个重要参数：
    * corePoolSize:核心线程数
    * maximumPoolSize:最大可扩展线程数
    * keepAliveTime:生存时间
    * TimeUnit:时间单位
    * workQueue：阻塞队列：阻塞队列会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）
    * threadFactory：线程工厂
    * handler：拒绝策略
  * 线程池底层工作原理：
    * 初始化线程池，线程数为0
    * 通过submit、execute方法向线程池提交任务时，线程会做如下判断：
      * 判断核心线程数是否已满，未满则创建新的线程处理任务
      * 如果核心线程数已满，再去判断阻塞队列是否已满，未满则放入阻塞队列
      * 如果阻塞队列已满，再去判断最大可扩展线程数是否已满，未满则创建新的线程处理任务
      * 如果最大可扩展已满，则交给拒绝策略（四个拒绝策略：AbortPolicy:一旦触发就会抛出异常，CallerRunsPolicy:调用者执行，DisCardOldestPolicy:丢弃等待最久的，DisCardPolicy：默默的丢弃任务，自定义拒绝策略：实现RejectedExecutionHandler接口）
    * 一个线程处理完任务之后，从阻塞队列中获取新的任务
    * 一个线程空闲时间到达生存时间，判断当前线程数是否大于核心线程数。大于则销毁该线程，直到回缩至核心线程数
  * 一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保存当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。
  * excute和submit区别，submit有返回值，而excute没有，submit方便exception的处理，

- [ ] CountDownLatch 与 join 方法的区别？

  * 调用一个子线程的join（）方法后，该线程会一直被阻塞直到该线程运行完毕，等待的任务必须都执行完才能放行；CountDownLatch在任何地方调用countdown方法放行，而不一定必须等线程结束。另外使用线程池来管理线程时候一般都是直接添加 Runnable 到线程池这时候就没有办法在调用线程的 join 方法了，countDownLatch 相比 Join 方法让我们对线程同步有更灵活的控制。

- [ ] CyclicBarrier和CountDownLatch的区别？

  * CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；CountDownLatch允许一个或多个线程**等待一组事件的产生**，而CyclicBarrier用于等待其他线程**运行到栅栏位置**。（比如打怪，所有的"过关了"都是由最后到达await方法的线程执行打印的）

- [x] Callable接口与Runnable接口的区别？

  相同点：都是函数式接口，都可以编写多线程程序，都采用Thread.start()启动

  不同点：

  * 具体方法不同，一个是run(),一个是call()
  * Runnable没有返回值，Callable可以返回执行结果，是个泛型
  * Callable接口的call（）方法允许抛出异常，Runnable的run（）方法异常只能在内部消化，不能往上继续抛。
  * Callable需要FutrueTask才能初始化多线程程序
  * Callable提供了检查计算是否完成的方法,以等待计算的完成，并检索计算的结果。 

- [ ] MONICA_:

- [ ] 异步编排怎么实现的

  * 项目中查询商品详情页的时候要远程调用商品管理微服务，库存微服务，营销属性微服务，查询商品的销售属性，营销属性等信息，因为这些接口的调用是无顺序的，jdk1.8为我们提供了一个CompleteableFuture类，有50个方法，方便我们实现异步编排，通过调用有返回值和无返回值方法，创建异步任务交给线程池执行，调用allof和join方法进行编排和执行。


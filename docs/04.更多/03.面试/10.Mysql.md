---
title: Mysql
date: 2021-12-19 23:14:23
permalink: /pages/ae0a93/
categories: 
  - 更多
  - 面试
tags: 
  - null
author: 
  name: MoXi
  link: https://github.com/zhangxiansheng123
---
* 你们的mysql数据库用的是什么引擎
  * MySQL-5.5 以及之后版本默认存储引擎是innodb,我们使用的innodb，
* Mysql有几种引擎，说说mysql引擎的特性，区别是什么
  * mysql有很多种引擎，常用的有三种InnoDB Myisam Memory，InnoDB跟Myisam的默认索引是B+tree，Memory的默认索引是hash，InnoDB支持事务，支持外键，支持行锁，写速度（百万级别的数据）远远慢于MyISAM，读的速度也不是很快，虽然速度慢，但是增删有事务不错，慢点可以接受，不仅缓存索引还缓存数据，MySQL5.6版本以上才支持全文索引（倒排索引），通过bin-log 进行灾难恢复和做数据库主从，Myisam只缓存索引不缓存数据，不支持事务和外键，支持表锁，支持全文索引，读取数据快（这方面性能较高），不支持崩溃后灾难恢复，Memory（还不如用Redis）所有的数据都保留在内存中,不需要进行磁盘的IO所以读取的速度很快, 但是一旦关机的话表的结构会保留，但是数据就会丢失,表支持Hash索引，因此查找速度很快。
* MySQL有哪些存储引擎，Memory引擎是用来干什么的
  * 不需要事务支持，**日志型应用** —— 用 MyISAM ，因为大多数都是只读的，且插入速度也比较快
  * **只读或者大部分情况下只读的表** —— 也应该用 MyISAM。
  * Memory（还不如用Redis）所有的数据都保留在内存中,不需要进行磁盘的IO所以读取的速度很快, 但是一旦关机的话表的结构会保留，但是数据就会丢失,表支持Hash索引，因此查找速度很快。
* 手写查询student里面求age最大的
* mysql是行锁还是表锁
  * 如果你引擎使用的Myisam那么mysql则是行锁，如果使用的是innodb默认是行表，如果隔离级别是可串行化则是表锁。
* sql的问题（超级多）
* 包括但不限于根据多条属性进行排序，去重，查重，各连接方式
* 回表了解吗？
  * 回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树。因此，可以通过索引先查询出id字段，再通过主键id字段，查询行中的字段数据，即通过再次查询提供MySQL查询速度。（只有主键索引的叶子节点有数据）
* mysql有缓存吗
* mysql的查询流程:
  * <font color='red'>mysql客户端通过协议与mysql服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果</font>，否则<font color='red'>mysql解析器将使用mysql语法规则验证和解析查询</font>，通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”，预处理器则根据一些mysql规则进一步检查解析树是否合法。合法会生成新的解析树，<font color='red'>查询优化器将其转化成执行计划</font>（一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划）然后通过查询执行引擎，通过API接口查询存储引擎，将数据返回，并存入缓存，提高下次查询效率。
* 
* 建一个索引，底层是存储一个字段还是存储整个表？
* mysql索引分类
  * 主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引
  * 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引
  * 唯一索引：索引列的值必须唯一，但允许有空值
  * 复合索引：即一个索引包含多个列
* 更新sql语句怎么写？什么时候用到单值索引？
* 数据库表行列转换
* 我的id主键，自增长乱了，怎么解决？索引失效了怎么办，比如用like 和"%_" 百分号的时候，怎么用最快的效率查询你想要的数据？
* 往mysql里面插入数据，写入的时间和我系统的时间不一样，有两个小时的时间差，怎么办，怎么解决？
* mysql和orcal有什么区别，你了解过吗？（我说引擎不同）
  * 并发性：mysql以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，那么仍然使用表级锁。oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以oracle对并发性的支持要好很多。
  * 隔离级别：mysql默认隔离级别可重复读，oracle默认隔离级别读已提交
  * 提交方式：oracle默认不自动提交，需要用户手动提交。mysql默认是自动提交。
  * sql语句的扩展和灵活性：oracle相比mysql语法更加严格
* b+树 知道吗
* 有十个数据，然后他让画一下b+树得存储结构
* 聊一下数据库索引？
  * **数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。**
  * 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往<font color='red'>以索引文件的形式存储的磁盘上</font>
  * 优势：类似图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本；通过索引列对数据进行排序或分组，<font color='red'>降低数据排序的成本</font>，降低了CPU的消耗。
  * 劣势：索引虽然大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息，底层要维护高度平衡树，增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。
  * 索引结构B+树
  * **聚簇索引**：将数据存储与索引放到了一块，找到索引也就找到了数据
  * **非聚簇索引**:将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。非聚簇索引又称辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值
* Btree与B+tree的区别，b+tree叶子结点存储多少数据，b+tree的高度
  * btree节点即存关键字又存记录，而b+tree只有叶子存储记录，非叶子节点只存key，这样存的key就多，降低了树的高度，提高了查询效率。
* 聚簇索引与非聚簇索引的区别
* 查询一张表的数据经过几次io
* 一般怎么进行sql优化，怎么查看是否用了索引，explain主要需要关注那几个字段，type字段都有哪些值
  * 使用explain，
* 说说explain关键字。
* mysql怎么查看有没有用到索引？（我回答的用explain，然后他又问到怎么判断的，我说看type类型是否是index）
  * 通过解析函数explain,进行分析，type显示的是访问类型一般来说得保证查询至少达到range级别，最好能达到此ref(常见：system > const > eq_ref > ref > <font color='#FFD700'>range</font> ><font color="orange"> index</font> > <font color="red">ALL </font>)，key表示实际使用到的索引,如果为null则没有使用索引。
  * key_len字段能够帮你检查是否充分的利用上了索引，计算方式：
    * 先看索引上字段的类型+长度比如 int=4 ;  varchar(20) =20 ; char(20) =20  
    * 如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8  要乘 3,GBK要乘2
    * varchar这种动态字符串要加2个字节
    * 允许为空的字段要加1个字节  
    * 例如：user varchar(30) utf8 允许为空：30 * 3 + 2 + 1 =  93
* 索引用过吗，怎么看sql有没有用到索引，sql优化，复合索引
* Sql如何优化
* mysql优化的方法有哪些
* mysql主键索引和组合索引的区别
* 组合索引是创建了几个索引
* 常用的sql优化有那些思路？通过什么命令可以看有没有用到索引？explin需要注意哪些字段？type字段有哪些值？ref是什么级别？
* 在你们项目中 怎么MySQL得调优
* MySQL了解吗，我说基本的语句都会写，然后他介绍说以后项目可能需要分库，但是没往下问
* Sql优化的步骤，sql优化?
* 查一条sql是否用到了索引的关键字是什么
* 关于具体是否使用到索引具体看那些参数
* 数据库索引有哪些 什么情况下失效 ，怎么造成索引失效！
  * 在索引列上操作（**计算、函数、(自动or手动，比如使用字符串类型不加单引号，MySQL底层会做自动类型转换)类型转换**），会导致索引失效而转向全表扫描。
  * **like以通配符开头**('%abc...')mysql索引失效会变成全表扫描的操作
  * mysql 在使用**不等于(!=或者<>)**的时候无法使用索引会导致全表扫描
  * **is not null** 也无法使用索引，但是is null是可以使用索引的
  * **字符串不加单引号**索引失效
  * 扩展：其实`IS NOT NULL`、`!=`这些条件说索引失效是不准确的，使不使用依据是根据花费的成本，成本有两个方面组成：读取二级索引记录的成本，将二级索引记录执行回表操作，也就是到聚簇索引中找到完整的用户记录的操作所付出的成本。成本小就使用。
* 什么情况下mysql连接池会满？ 
* mysql连接池满了怎么办？
* 如何查询特别慢的sql语句。
  * 打开慢查询，将慢查询时间设置为一秒，设置慢查询日志的保存位置，查看生成的日志，找到对应的sql语句。
* 索引失效的情况
* 订单表是否需要添加索引？
* 什么是幻读
* 如何控制事务，控制事务的原理
* mysql事务
* 事务：逻辑上的一组操作，组成这组操作的各个逻辑单元，要么全成功，要么全失败。

  * 四大特性：ACID
    * 原子性：Atomic，不可分割性。
    * 一致性：Consistency，要成功都成功，要失败都失败
    * 隔离性：Isolation，事务之间不应该相互影响
    * 持久性：Durablility，持久化到硬盘
  * 事务读并发问题：
    * 脏读：一个事务读取到另一个事务未提交的数据
    * 不可重复读：一个事务读取到另一个事务已提交的数据。更新，锁行
    * 虚读、幻读：一个事务读取到另一个事务已提交的数据。新增、删除，锁表
    * 不可重复读以及虚读或者幻读是适当允许发生的。
  * 四个隔离级别：
    * 读未提交：read uncommitted。导致脏读、不可重复读、虚读/幻读
    * 读已提交：read committed。解决脏读。依然会出现不可重复读、虚读/幻读。oracle默认隔离级别
    * 可重复读：repeatable read。解决脏读、不可重复读。依然会出现虚读/幻读。mysql默认隔离级别
    * 序列化读：serializable。解决所有问题
    * 隔离级别越高，性能越低，安全性越高
* 如何防止SQL注入

  * 在表单中输入sql语句的片段，对没有输入检验的网站可能带来毁灭性的打击，轻则绕过登录，重则删库、泄露数据。
  * sql注入只会发生在sql编译的过程中，那么避免非法sql语句被编译，就是我们要做的事情。
    * 在JDBC中，使用Statement的子类PreparedStatement，事先将sql语句传入PreparedStatement中，等会要传入的参数使用？代替，那么该sql语句会进行预编译，之后将前台获取的参数通过set方式传入编译后的sql语句中，那么此时被注入的sql语句无法得到编译，从而避免了sql注入的问题。而且使用PreparedStatement在一定程度上有助于数据库执行性能的提升。
    * Mybatis中尽量使用#｛｝而不是$｛｝，\#｛｝就像是JDBC中的？，mybatis通过使用#｛｝的方式，代表该语句在执行之前会经过预编译的过程，后来传入的参数通过占位符的方式填入到已经编译完的语句中。但使用$｛｝的参数会直接参与编译，不能避免sql注入。如果需求中非要使用到$｛｝的话，只能前台过滤了。
    * 前台过滤使用正则或者字符串过滤检查不合法字符返回参数不合法。
* SQL的having和where的区别（select distinct   from   where  group by having orderby）

  * where ：where 是一个约束声明，使用where来约束来自数据库的数据。
  * where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即**在分组之前过滤数据**，条件中不能包含聚合函数，使用where条件显示特定的行。
  * where中不能使用聚合函数,因为where执行顺序大于聚合函数。
  * having是一个过滤声明
  * 在查询返回结果集以后对查询结果进行的过滤操作
  * having 子句的作用是筛选满足条件的组，即**在分组之后过滤数据**，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。
  * 执行顺序：where>groupby>聚合函数(sum,min,max,avg,count)>having
* 怎么实现数据库分页
* 数据库的更新策略。。。
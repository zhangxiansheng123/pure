---
title: JVM
date: 2021-12-19 22:56:40
permalink: /pages/cbd6ba/
categories: 
  - 更多
  - 面试
tags: 
  - null
author: 
  name: MoXi
  link: https://github.com/zhangxiansheng123
---
## JVM

* JVM类加载原理

* 类初始化过程

* classloader这个类做了什么

* 请谈谈你对JVM 的理解？java8 的虚拟机有什么更新？

  * 首先JVM由类装载器、运行时数据区、执行引擎、本地方法接口和本地方法库组成。

    * 类加载器负责加载class文件，class 文件在文件开头有特定的文件标识，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。

      * 类加载器分为四种：前三种为Java虚拟机自带的加载器

        * 启动类加载器（BootStrap）C++

          负责加载$JAVA_HOME中的jre/lib/rt.jar里所有的class,由C++实现，不是ClassLoader的子类。

        * 扩展类加载器（Extension）Java

          负责加载java平台中除了rt.jar之外的**扩展功能**的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

        * 应用程序加载器（AppClassLoader）Java

        * 用户自定义加载器 继承Java.lang.ClassLoader后，用户可以定制类的加载方式。

      * 类加载器工作过程：（双亲委派模式）

        * 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
        * 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
        * 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载。
        * 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载
        * 如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

      其实这就是所谓的双亲委派模型。简单来说一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。

      好处：**防止内存中出现多份一样的字节码**（保证了安全性和稳定性）。

    * 运行时数据区主要包括（其中方法区和堆为线程所共享，这些区域随着虚拟机的启动而创建，随着虚拟机的关闭而销毁，虚拟机栈、程序计数器、本地方法栈为线程所私有，随着线程的开始而创建，随着线程的结束而销毁。）

      * 方法区：存储已经被虚拟机加载的类元数据信息（元空间）（在方法区中,存储了每个类的信息(包括类的名称,方法信息,字段信息)、静态变量、常量以及编译器编译后的代码等。 在Class文件中除了类的字段、方法、接口等描述信息外,还有一项信息是常量池,用来存储编译期间生成的字面量和符号引用。在方法区中有一个非常重要的部分就是运行时常量池,它是每一个类或接口的常量池的运行时表示形式,在类和接口被加载到JVM后,对应的运行时常量池就被创建出来。当然并非只有Class文件常量池中的内容才能进入运行时常量池,在运行期间也可将新的常量放入运行时常量池中,比如String的intern方法。）从JDK8开始，方法区被元数据区替代了。（**静态变量+常量+类信息(构造方法/接口定义)+运行时常量池**存在方法区中，但是**实例变量存在堆内存**中,和方法区无关）
      * 堆：存放对象实例，几乎所用的对象实例都在这里分配内存
      * Java虚拟机栈：虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧，栈帧中主要保存3 类数据：本地变量（输入参数和输出参数以及方法内的变量。）、栈操作（记录出栈、入栈的操作。）、栈帧数据（包括类文件、方法等）（**8种基本类型的变量+对象的引用变量+实例方法**都是在函数的栈内存中分配。）
      * 程序计数器：每个线程都有一个程序计数器，是**线程私有的**，就是一个指针，指向方法区中的方法字节码（**用来存储指向下一条指令的地址**，即 将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
      * 本地方法栈：Native Method Stack中登记native方法，在Execution Engine 执行时通过Native Interface加载本地方法库。

    * 执行引擎Execution Engine：

      * 如果想让一个Java程序运行起来，执行引擎Execution Engine将字节码指令解释/编译为对应平台上的本地机器指令才可以，提交操作系统执行。（通常java跨平台是因为jvm本质是执行引擎）

    * 本地接口Native Interface

      * 本地接口的作用是为了融合不同编程语言为Java所用（主要是C/C++），于是在内存开辟了一块区域处理标记为native的代码，具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies.

      

* 变量什么情况下会被垃圾回收

* 什么是OOM ？什么是StackOverflowError？有哪些方法分析？

  * OOM(OutOfMemoryError)出现在养老区和永久区，若养老区执行了两次Full GC之后发现依然无法进行对象的保存，就会产生OOM异常,如果出现<font color='red'>java.lang.OutOfMemoryError: Java heap space</font>异常，说明Java虚拟机的堆内存不够。原因有二：**（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。****（2）**代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。**	如果出现<font color='red'>java.lang.OutOfMemoryError: PermGen space</font>，**可能是Java虚拟机对永久代Perm内存设置不够、程序启动加载大量的第三方jar包。tomcat中运行了太多的项目、或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。** Jdk1.6及之前： 有永久代，常量池1.6在方法区，Jdk1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。**Jdk1.8及之后： 无永久代，常量池1.8在元空间（Metaspace）**
  * StackOverflowError一般出现在方法的递归调用中。
  * 分析方法：在Eclipse中MAT工具的使用，在idea中修改配置参数生成dump文件后缀为**.hprof，使用jdk自带的文件解读工具jvisualvm.exe分析

* jvm调优过没

* jvm你怎么优化的

* JVM 的常用参数调优你知道哪些？

  * -Xms :初始堆大小。只要启动，就占用的堆大小，默认是内存的1/64

  * -Xmx:最大堆大小。默认是内存的1/4

  * -Xmn:新生区堆大小

  * -XX:+PrintGCDetails:输出详细的GC处理日志

  * 命令：java -Xms20m -Xmx50m xx.class

    jps -l：查看服务器的所有java进程
    jinfo -flags 进程号：查看进程的jvm参数设置
    jstat -gc 进程号：查看jvm结构，GC情况

* 内存快照抓取和MAT分析DUMP文件知道吗？

* 谈谈JVM中，对类加载器你的认识？

* JVM内存模型以及分区，需要详细到每个区放什么

* 堆中的区域划分

* 堆里面的分区：Eden，survival from to，老年代，各自的特点。

  * 新生区是对象的诞生、成长、消亡的区域，一个对象在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的对象都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。
  * 老年代：经历多次GC仍然存在的对象（默认是15次），老年代的对象比较稳定，不会频繁的GC
  * 永久代：永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。

* 新生代的垃圾回收什么时候触发

  * eden满了会发生minorGC

* 老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少

  * 当老年代没有足够空间存放对象时，会触发一次FullGC，fullGC之前伴随着一次monorGC
  * 一般是两个原因引起的，要么是老年代内存过小，要么是老年代连续内存过小，存放不下对象了，如果元空间区域的内存达到了所设定的阈值-XX:MetaspaceSize=，也会触发FullGC

* GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方

  * 复制算法：把内存平均分成两份，只使用其中一份，这一份内存满了之后，把存活对象copy到另一半内存。清空满了的那一半内存。
    * 优点：对象存活率不高的情况下简单高效  不会产生内存碎片
    * 缺点：浪费一般内存空间   对象存活率较高的情况下，所有对象都要copy，并重置指针，效率不高
    * 新生代（对象存活率不高，不会超过10%）使用的垃圾回收算法就是复制算法。
  * 标记清除算法：分成两个阶段:
    * 标记阶段：标记出需要回收的对象，使用的标记算法均为**可达性分析算法**。
    * 清除阶段：清除死亡的对象，回收被标记的对象。
    * 缺点：经过两次遍历，效率不高，产生大量的内存碎片
  * 标记整理（压缩算法）：标记-整理法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是通过**所有存活对像都向一端移动，然后直接清除边界以外的内存。**
    * 优点：避免了一半内存的浪费，避免了内存碎片的产生
    * 缺点：两次遍历效率不高，移动对象并重置指针，效率更低。

  **老年代一般是由标记清除或者是标记清除与标记整理的混合实现。**

* Minor GC与Full GC分别在什么时候发生。

* 四种引用

  * 强：new User()，强引用只要存在引用就不会被垃圾回收器回收
  * 软：通过SoftReference初始化一个软引用，一旦将要发生OOM都会被垃圾回收器回收。高速缓存
  * 弱：通过WeakReference初始化，一旦发生GC就会被垃圾回收器回收
  * PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

* JVM垃圾判定算法：（对象已死？）

  * 引用计数法(Reference-Counting)

    * 引用计数算法是通过判断对象的**引用数量**来决定对象是否可以被回收。

    * 优点：简单，高效，现在的objective-c、python等用的就是这种算法。

    * 缺点：引用和去引用伴随着加减算法，影响性能

    * 很难处理循环引用，相互引用的两个对象则无法释放，可能产生内存泄漏（两个对象相互引用）。

      **因此目前主流的Java虚拟机都摒弃掉了这种算法**。

  * 可达性分析算法（根搜索算法）

    * 这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。
    * 在Java语言中，可以作为GC Roots的对象包括下面几种：
      * 虚拟机栈（栈帧中的本地变量表）中的引用对象。
      * 方法区中的类静态属性引用的对象。
      * 方法区中的常量引用的对象。 
      * 本地方法栈中JNI（Native方法）的引用对象

  **真正标记以为对象为可回收状态至少要标记两次。**

* GC垃圾回收主要有四大算法：（怎么找到已死对象并清除？）

  * 复制算法(Copying)

  * 标记清除(Mark-Sweep)

  * 标记压缩(Mark-Compact)，又称标记整理

  * 分代收集算法(Generational-Collection)

    * 分代回收算法：其实不是一种真正意义上的算法。

      * 内存利用率：标记整理算法  >  标记清除算法 > 复制算法

      * 内存连续性：标记整理算法 = 复制算法 > 标记清除算法

      * 效率：对象存活率不高：复制算法  > 标记清除算法 > 标记整理算法

        ​			对象存活率高：标记清除算法 > 复制算法 > 标记整理算法

      * 新生代对象存活率不高：选择复制算法

      * 老年代对象存活率较高：选择标记清除算法 标记整理算法

* 垃圾回收器有哪些 都有那些算法来实现项目中用的垃圾回收器是什么

* 垃圾回收器：是垃圾算法的具体实现

  * serial（复制算法）/serial old（标记压缩）：串行的垃圾回收器。客户端程序选择
  * parallel/parallel old（标记压缩）：服务器端项目
  * CMS（标记清除算法）：可预测的停顿时间
    * 初始标记阶段：只标记出GCRoot对象或者GCRoot对象直达的对象，会导致STW
    * 并发标记阶段：标记出所有存活对象，不会产生STW
    * 重新标记阶段：标记出上一个阶段没有标记到的对象。会导致STW
    * 清除阶段：清除垃圾对象，不会产生STW
    * 优点：高效，低停顿高吞吐量
    * 缺点：可能会产生大量的内存碎片，在运行时间比较久之后，服务会越来越慢
  * G1：类似于CMS
    * 大小相等的区块组成，优先回收垃圾率较高的区块

* 聊一下GC？

* 常用的GC算法有哪些，分别用在什么时候，GC收集器有哪些？

* 常用的jvm常用算法及垃圾回收器有哪些？

* Jvm的内存模型
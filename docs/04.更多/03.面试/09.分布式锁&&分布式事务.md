---
title: 分布式锁&&分布式事务
date: 2021-12-22 22:44:18
permalink: /pages/54a537/
categories:
  - 更多
  - 面试
tags:
  - 
---
* 分布式锁是什么,分布式锁用过没，说说分布式锁，分布式锁和非分布式锁的区别

  * 我们在开发应用时，如果需要对某一个共享变量进行多线程同步访问的时候，由于目前java中的synchronized或者juc包中的锁都是针对单个jvm的，分布式环境下就无能为力，只能用分布式锁；

* 分布式锁的原理，项目中分布式锁的体现

* 分布式锁怎么实现，如何防止击穿

* Redisson做分布式锁的时候式如何保证不会死锁

* 当线程获取Redisson之后，执行期间Redisson过期时间到了，该怎么办

* 如果不加分布式锁会怎样

* 谈谈对分布式锁的理解，怎么实现分布式锁？

  * 分布式锁要解决的问题，就是由于分布式系统多线程、多进程并且分布在不同机器上，原单机部署情况下的并发控制锁策略就失效了，单纯的Java Api和数据库不能提供分布式锁的能力。这时候就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。

  * 3种 主流实现：

    * 基于关系型数据库mysql实现
    * 基于redis实现
    * 基于zookeeper实现
    * 性能：redis > zookeeper > mysql
    * 安全：zookeeper （高度一致性）> redis == mysql
    * 复杂度：zookeeper > mysql > redis

  * 实现分布式锁应该具有的特点：

    * 排他互斥：setnx

    * 防死锁：

      * 获取到锁之后，服务立马宕机，没有机会释放锁。

        解决方案设置过期时间：expire   或者  set key value ex 3 nx（只在键不存在时， 才对键进行设置操作，`XX` ： 只在键已经存在时， 才对键进行设置操作）

      * 不可重入

    * 保证原子性：

      * 获取锁和设置过期时间要保证原子性
      * 释放锁时，判断和删除之间也要保证原子性，使用lua脚本

    * 防误删：删除时需要判断是否自己的锁

    * 过期时间自动续期

    * 可重入

* 分布式锁包含三个部分：

  * 加锁：setnx
  * 释放锁：del
  * 重试：

  

## 分布式事务

分布式集群对于请求，你们是怎么保证事务的一致性？

分布式事务：

* 逻辑上的一组操作，组成这组操作的各个逻辑单元在不同的服务中，不同的服务器上，要么都成功，要么都失败。

* 场景：

  * 不同服务，不同数据库
  * 相同服务，不同数据库
  * 不同服务，相同数据库

* 情况：除了本地事务的程序异常之外，网络异常、服务器宕机

* 分布式事务基础理论：

  * CAP：
    * C：一致性。写完之后立马可以读取到最新数据
    * A：可用性。挂掉一台服务器依然可用
    * P：分区容忍性。分区通信失败是无法避免
    * C和A是相互矛盾的，P是无法避免的。在开发时，要么追求CP，要么追求AP（一般）
  * BaSE：妥协的方案，本质就是一个追求AP的方案
    * Ba：基本可用。保证核心功能可用
    * S：软状态，中间状态。允许一定时间内的数据不一致
    * E：最终一致性。

* 没有完美的方案，强一致性和弱一致性

* 3种解决方案：

  * 两阶段提交2PC
    * 2是指两个阶段
    * P：Prepared phrase，预提交阶段
    * C：Commit，提交阶段
    * 主流的商业数据库都已经支持了两阶段提交：XA协议，免费开源的数据库支持的还不够完善
    * 优点：实现简单
    * 缺点：1.开源数据库会存在支持问题2.经过多次网络传输，导致性能存在问题3.总的访问时间变长，导致总的锁定时间变长。
  * TCC补偿性事务：编程式解决方案
    * T：Try，预检资源并锁定资源
    * C：Confirm，执行业务流程
    * C：Cancel，如果try失败则取消事务，如果confirm执行失败，要进行补偿
  * MQ最终一致性
    * 追求一致性：2PC
    * 追求性能：MQ最终一致性

* seata：一站式分布式事务解决方案。AT模式

* 概念：

  * 全局事务：全局事务由一系列的分支事务组成
  * 分支事务：就是一个本地事务
  * TC：事务协调器，负责维护全局事务的运行状态，并且可以驱动全局事务的提交或者回滚
  * TM：事务管理器，负责控制全局事务的边界，开启全局事务，并且发起全局事务的提交或者回滚的决议
  * RM：资源管理器，负责控制本地事务，维护本地事务的状态，接受提交或者回滚的指令，执行本地事务的提交或者回滚

* seata的执行流程、生命周期：

  * TM向TC申请开启一个全局事务，全局事务开启成功并生成一个全局唯一的XID
  * XID在微服务调用链路的上下文中传播
  * RM向TC注册分支事务，TC把分支事务纳入XID对应全局事务的范围中
  * TM向TC发起全局事物的提交或者回滚的决议
  * TC协调RM执行分支事务的提交或者回滚

* 传播行为：一个service方法调用另一个service的方法时，事务之间的影响（注意是不同service）

* 回滚策略：默认回滚策略：受检异常（编译时异常）都不会回滚，不受检异常都会回滚

* 超时事务：timeout设置超时时间。

* 只读事务：readOnly=true，只能操作查询


---
title: Redis
date: 2021-12-22 23:03:08
permalink: /pages/d4fad5/
categories:
  - 更多
  - 面试
tags:
  - 
---
* 讲一下redis

* 关于redis有哪些中间件

* 为什么Redis的操作是原子性的，怎么保证原子性的？多个命令在并发中也是原子性的吗？

  * 对于redis来说，命令的原子性指的是：一个操作不能再分，操作要么执行，要么不执行。
  * redis的操作之所以是原子性的，是因为redis是单线程
  * redis本身的所有api都是原子操作，redis中的事务其实是要保证批量操作的原子性。
  * 多个命令在并发中不一定是原子性的，使用Redis的事务，或者使用Redis+Lua==的方式实现.

* redis与memcached区别

  * Memcache是串行+多线程+锁的方式,只支持string（value值1M）,不支持持久化，数据全存在内存，断电消失。Redis采用单线程操作，
  * redis支持多种数据类型，支持持久化，value最大值512，redis是单线程+多路复用实现。

* redis是单线程还是多线程，redis为什么快， redis的多路复用 *3

  * redis是单线程的，redis 是基于内存操作，CPU不是Redis性能瓶颈，而是根据机器的内存和网络带宽，高性能的服务器并不都是多线程的，因为多线程CPU上下文切换会耗时，redis将所有的数据放在内存中，所以单线程操作效率是最高的，多线程操作对于内存系统来说会有CPU上下文切换耗时。（读写速度：CPU>内存>硬盘）
  * redis是跑在单线程中的所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的所以I/O操作在一般情况下往往不能直接返回，这导致某一文件的I/O阻塞导致整个进程无法对其他客户提供服务而I/O多路复用就是为了解决这个问题出现的。IO多路复用其实是在单个线程中通过记录跟踪每一个sock(I/O流)的状态来管理多个流，常见的select、poll、epoll都是I/O多路复用的具体体现，I/O多路复用的所有功能都是通过包装常见的select、epoll、poll这些I/O多路复用函数库来实现的。多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪,则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作。select仅仅知道有I/O事件的发生，却不知道是哪几个流，（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。poll本质上和select没有区别，但是它没有最大连接的限制。**epoll可以理解为event poll**，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们（复杂度O1）

* redis的数据类型  *2

  * redis常用的存储格式
  * 常用的有五大数据类型
    * String类型是最基本的数据类型，一个key对应一个value，是二进制安全的意味着String可以包含任何数据，比如图片或者序列化对象，一个redis中字符串的value最多可以是512M
    * list,单键多值，是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）和尾部（右边）。它的底层实际上是个双向链表，对两端的操作性能很高，通过索引操作中间的节点性能会较差。
    * set对外提供的功能与list类似是一个列表的功能，不同之处是set是可以自动排重的。当存储列表数据又不想有重复数据时可以选用。并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)
    * hash 是一个键值对集合，hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。eg:   hset <key>  <field>  <value>    	
    * zset有序集合，与set相似，是一个没有重复元素的字符串集合，不同之处是有序集合中的每个成员都关联了一个得分score用来排序集合中的成员，评分可以重复。

* redis集群中每个redis数据一致吗  他们之间是怎么通信的

* redis的抛弃策略

  - noeviction：默认策略，不淘汰，如果内存已经满了，添加数据报错；
  - volatile-lru：根据近似lru算法（最近最少使用）进行淘汰，在设置了过期时间的所有键中，选取最近最少使用的数据抛弃，但不会丢弃没有设置过期时间的key；
  - volatile-ttl：比较有过期时间的key的寿命，寿命短的先淘汰；
  - volatile-random：从设置了过期时间的key中随机选择key进行淘汰；
  - allkeys-lru：在所有键中，选取最近最少使用的数据抛弃。
  - allkeys-random：和volatile-random相比，淘汰范围从所有设置了过期时间的key，扩展到了所有的key（包含没有设置过期时间的key）。

* redis如何用string类型存放一个类

  * 可以将类序列化为string字符串

* redis的持久化方式，你们项目中使用的哪种

* redis的持久化工作怎么做的？数据存储在哪儿？？？项目宕机后，redis怎么处理

* redis中：需求场景：假如我要缓存所有的商品id到redis中，然后前端一个请求过来，我要去redis中判断这ID是否存在，用什么数据类型存储比较好？

* redis持久化的方式？redis缓存淘汰策略？如果对一个字段进行修改，它会怎么处理？是先写缓存还是先写数据库，还是怎么顺序？

* 在不使用canal的情况下，如何保证数据库更改数据时同步到redis中

* redis使用场景，目的 ，redis和memcache区别？如何实现？

  * 数据访问频繁
  * 写的频率非常少
  * 目的：缩短业务流程，进而减少了响应时间，进而提高了并发能力，保护数据库。
  * 实现：spring-cache（@EnableCache @Cacheable @CacheEvit）
    * 先查询缓存，缓存中有直接命中返回
    * 缓存中没有，查询数据库或者远程调用获取数据，并放入缓存

* 缓存写的一致性问题

  * 双写模式：不管先写谁都可以出现数据不一致：
    * 先写mysql，再写redis。后续代码出现异常，mysql会回滚，redis不会回滚，导致数据不一致
    * 先写redis，再写mysql。写redis成功，写mysql失败，数据不一致。
  * 失效模式：
    * 先删redis还是后删redis都会出现，事务还未提交，另一个线程读取数据，重新把旧数据放入缓存，此时再去提交，就会出现数据不一致。
  * 双删模式
    * 先删redis
    * 再写mysql
    * 再异步删除redis
  * canal中间

* 读的并发问题

  * 缓存穿透：大量的请求同时访问不存在的数据，就会越过缓存到达数据库。导致mysql宕机。比如说：根据产品id获取产品详情的接口，那么我用一个id=-1去请求，那肯定是获取不到任何数据的。一般这样的情况有可能服务器遭到了恶意攻击。
  * 解决方案：数据即使为null也缓存；布隆过滤器，在用户请求的接口层增加一些校验，例如：用户鉴权校验、参数传值校验等不合法的参数请求即直接返回。
  * 缓存雪崩：缓存时间相同导致大量的缓存数据同时过期，此时大量请求进来，就会直达数据库，导致mysql宕机。
  * 解决方案：给缓存时间设置一个随机值，也可以热点数据永不过期，如果有数据更新就直接更新redis即可
  * 缓存击穿：一个热点key过期，此时大量请求同时访问该数据，就会直达数据库，导致mysql宕机。服务器熔断、降级，限制每个用户的访问次数，并且如果获取不到数据即返回一个固定的推荐页面
  * 解决方案：设置这个key永远不会过期，加jvm锁（synchronized ReentrantLock），分布式锁

* redis熟不熟悉 用在哪里 有什么作用

* redis配置文件流程

* redis的数据结构（我展开说了各个类型一般怎么用）和哨兵是什么？数据一致性的问题都有那些解决方案？我还说了在项目中哪些地方用到了redis。

* 为什么redis存储你们使用了使用hash结构map（key，map（key，value）），为什么不用kv存储

* 布隆过滤器原理了解吗

  * 使用Redis高级数据结构布隆过滤器，它就是检测数据库中是否存在该key，不存在就直接返回即可。

  * https://zhuanlan.zhihu.com/p/43263751布隆过滤器

    * 布隆过滤器的核心是实现一个超大位的数组（bitmap）和几个哈希函数，1、布隆需要记录见过的数据，这里的记录需要通过hash函数对数据进行hash操作，得到数组下标并存储在BIT 数组里记为1。这样的记录一个数据只占用1BIT空间。2、判断是否存在时：给布隆过滤器一个数据，进行hash得到下标，从BIT数组里取数据如果是1 则说明数据存在，如果是0 说明不存在。hash算法存在碰撞的可能，所以不同的数据可能hash为一个下标数据，故为了提高精确度就需要 使用多个hash 算法标记一个数据，和增大BIT数组的大小，也是因为如此，布隆过滤器判断为【数据存在】 可能数据并不存在，但是如果判断为【数据不存在】那么数据就一定是不存在的。不支持删除

* 你们为什么redis和mysql都存储了数据，存储到mysql的意义是什么

  * Redis基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，而内存成本较高；
  * 基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高；
  * 场景：多数时候是MySQL（主）+Redis（辅），MySQL做为主存储，Redis用于缓存，加快访问速度。需要高性能的地方使用Redis，不需要高性能的地方使用MySQL。一个优秀的网站不同模块一定是有对性能不同的要求的，性能要求高的模块我们使用redis(拿空间换速度)，其他模块使用性价比更高的mysql储存。

* redis集群主从复制

  * 主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，主机支持数据的写入和读取（以写为主）等各项操作，而从机则只支持与主机数据的同步和读取。
  * 三种主从模式
    * 一主二仆：每次从机联通后，都会给主机发送sync(同步)指令，主机立刻进行存盘操作，发送RDB文件给从机，从机收到RDB文件后覆盖自己的RDB文件，进行全盘加载，之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令。（主机宕机后从机原地待命）
    * 薪火相传：上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。使用slave of ip sort  风险是一旦某个slave宕机，后面的slave都没法备份, 主机挂了，从机还是从机，无法写数据了 ,去掉从服务器身份 slaveof no one
    * 反客为主：执行slave of no one 主机挂了，选举一个从机当主机。（哨兵是反客为主的自动版不用手动执行命令）
  * 优点：读写分离，性能扩展，容灾快速恢复

* redis的哨兵模式是做什么的？

* 你的redis版本是多少（4.0），集群是主从还是哨兵，哨兵是什么版本出现的

  * Sentinel(哨兵)是用于监控redis集群中Master状态的工具，是Redis 的高可用性解决方案，sentinel哨兵模式已经被集成在redis2.4之后的版本中。
  * 哨兵模式工作方式：
    * 每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送一个PING命令 ，用来心跳检测。
    * 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线。 
    * 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 
    * 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 
    * 在一般情况下， 每个 Sentinel 会以每10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 
    * 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （该命令第一个是用来发现slave节点,第二个是确定主从关系.）
    * 若没有足够数量的 Sentinel 同意Master 已经下线， Master 的客观下线状态就会被移除。 
    * 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。
    * 当master被确认下线后，在从服务中挑选一个作为主服务，选择优先级靠前的，偏移量最大的，runid最小的从服务作为主服务。挑选出新的主服务sentinel向原主服务的从服务，发送slaveof新主服务的命令，复制新master，当已经下线的服务重新上线时，sentinel会向其发送slave of 成为新主的从。（优先级在redis.conf中默认：slave-priority 100，值越小优先级越高，偏移量是指获得原主机数据最全的，每个redis实例启动后都会随机生成一个40位的runid）

* redis的持久化https://baijiahao.baidu.com/s?id=1654694618189745916&wfr=spider&for=pc

  * Redis支持RDB和AOF两种持久化机制，持久化功能能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前的持久化文件即可实现数据恢复。

  * RDB持久化：RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发（save，bgsave）和自动触发。（可能丢失最后一次保存）

    * save 触发：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。

    * **bgsave触发方式**：具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。

    * 自动触发是由我们的配置文件来完成的，

      ```java
      save 900 1 
      save 300 10
      save 60 10000
      ```

  * AOF做增量备份，每一个写命令都通过write函数追加到appendonly.aof 中。**AOF也有三种触发机制**

    * 每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好
    * 每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失
    * 不同no：从不同步
    * 优点：AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。
    * **缺点**：对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大，AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的，以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。

* redis分布式锁

* redis锁的机制

  * https://blog.csdn.net/weixin_30355437/article/details/95877375?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control

* redis中：需求场景：假如我要缓存所有的商品id到redis中，然后前端一个请求过来，我要去redis中判断这ID是否存在，用什么数据类型存储比较好？

  * set存储可以去重，set提供了判断某个成员是否存在，它底层其实是一个value为null的hash表